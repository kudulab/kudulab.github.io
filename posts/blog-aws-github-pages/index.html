<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
    <meta name="description" content="KuduLab - personal blog and open source projects">
    <meta name="keywords" content="blog,developer,continuous delivery,infrastructure,devops,IT,open source,gocd">

    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://kudulab.io/aws_dns_zone.png"/>

<meta name="twitter:title" content="Hugo blog on gh-pages with terraform and AWS Route 53"/>
<meta name="twitter:description" content="Walkthrough a Hugo blog setup on github pages with GoCD, Terraform, AWS Route 53, Dojo and Docker"/>

    <meta property="og:title" content="Hugo blog on gh-pages with terraform and AWS Route 53" />
<meta property="og:description" content="Walkthrough a Hugo blog setup on github pages with GoCD, Terraform, AWS Route 53, Dojo and Docker" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kudulab.io/posts/blog-aws-github-pages/" />

<meta property="og:image" content="https://kudulab.io/aws_dns_zone.png" />
<meta property="article:published_time" content="2019-04-24T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2019-04-24T00:00:00&#43;00:00"/>


    
      <base href="https://kudulab.io/posts/blog-aws-github-pages/">
    
    <title>
  Hugo blog on gh-pages with terraform and AWS Route 53 · KuduLab
</title>

    
      <link rel="canonical" href="https://kudulab.io/posts/blog-aws-github-pages/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://kudulab.io/css/coder.min.923b7a6f40696147de65ea4d2538660532f6c56de9cbbc51717213115bcaf18e.css" integrity="sha256-kjt6b0BpYUfeZepNJThmBTL2xW3py7xRcXITEVvK8Y4=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://kudulab.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://kudulab.io/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.55.1" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <img class="logo-img" src="https://kudulab.io/images/kudu-48x48.png" alt="Kudu Logo" />
    <a class="navigation-title" href="https://kudulab.io/">
      KuduLab
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://kudulab.io/">Home</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://kudulab.io/projects/">Projects</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://kudulab.io/contact/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">Hugo blog on gh-pages with terraform and AWS Route 53</h1>
        </div>
        <div class="post-meta">
          <span class="posted-on">
            <h4 class="post-author">by Tomasz Sętkowski</h4>
          </span>
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2019-04-24T00:00:00Z'>
                April 24, 2019
              </time>
            </span>
            <span class="reading-time">
              <i class="fas fa-clock"></i>
              16 minutes read
            </span>
          </div>
          
          
        </div>
      </header>

      <div>
        

<p>This is a self-referential post about deploying a personal blog on github pages.
It describes how <a href="https://kudulab.io">kudulab.io</a> is deployed, starting from scratch, ending with fully-working website deployed using best practices.</p>

<p>All of the supporting code is hosted on <a href="https://github.com/kudulab/public-blog">github</a>, just like all the open source tools used.</p>

<h3 id="audience">Audience</h3>

<p>This post will be most useful to someone building a personal website with similar <a href="#choosing-the-right-technologies">technologies</a>.
You may still find some pieces useful if you</p>

<ul>
<li>want to deploy a static site to <a href="https://pages.github.com/">github pages</a></li>
<li>are making first steps with <a href="https://www.terraform.io/">terraform</a></li>
<li>are learning to use the <a href="https://aws.amazon.com/route53/">AWS Route 53 DNS</a> via terraform AWS provider</li>
</ul>

<h2 id="the-requirement">The requirement</h2>

<p>We are faced with the following requirement:</p>

<ul>
<li>Build a website where content (posts and static pages) can be managed with markdown.</li>
<li>Content should be versioned in git, not served from database. <code>git push</code> should be sufficient to make modifications to the website. (aka <em>push to deploy</em>)</li>
<li>Allow the blog visitors to place comments under posts</li>
<li>Add web traffic monitoring</li>
<li>Site should be public, hosted on custom domain</li>
<li>Serve the site only over <code>https</code></li>
<li>The deployment must be fully automated.</li>
<li>All operations, infrastructure and development environment must be declared and versioned in code.</li>
<li>Keep the hosting costs low</li>
</ul>

<h3 id="choosing-the-right-technologies">Choosing the right technologies</h3>

<p>There are plenty of available solutions to meet above requirement. This is just one combination which we found to be acceptable. The solution goes like this:</p>

<ul>
<li>We use <strong><a href="https://gohugo.io/">Hugo</a></strong> - a static site generator to generate a <a href="https://en.wikipedia.org/wiki/Static_web_page">static page</a>.</li>
<li>The static web page is hosted by <strong><a href="https://pages.github.com/">Github Pages</a></strong>. A personal blog&rsquo;s traffic should be well within the <a href="https://help.github.com/en/articles/what-is-github-pages#usage-limits">github pages limits</a>. Github pages <a href="https://help.github.com/en/articles/using-a-custom-domain-with-github-pages">supports custom domains</a> and generating https certificates with <a href="https://letsencrypt.org/">Let&rsquo;s Encrypt</a>.</li>
<li>Since static pages cannot have dynamic content served by the same host, we need an external solution - we found <strong><a href="https://disqus.com/">Disqus</a></strong> offers a free plan for personal usage. It is also well <a href="https://gohugo.io/content-management/comments/#add-disqus">integrated with hugo</a>.</li>
<li>For web traffic monitoring we use <strong><a href="https://analytics.google.com/analytics/web/">google analytics</a></strong>. Which is also well <a href="https://gohugo.io/templates/internal/">integrated with hugo</a></li>
<li>To setup custom domain and manage the DNS records <strong>as code</strong>, we use <strong><a href="https://www.terraform.io/">Terraform</a></strong> and <strong><a href="https://aws.amazon.com/route53/">AWS Route 53 DNS</a></strong></li>
<li>To define <strong>operations as code</strong> we use bash scripts</li>
<li>To define a sufficient <strong>execution environment</strong> of each operation <strong>as code</strong> we use <strong><a href="https://github.com/ai-traders/dojo">Dojo</a></strong> together with <a href="https://github.com/kudulab/docker-terraform-dojo">terraform-dojo</a> docker image and <a href="https://github.com/kudulab/docker-hugo-dojo">hugo-dojo</a> docker image.</li>
<li>To automate and visualize the lifecycle of the website, we execute it on <strong><a href="https://www.gocd.org/">GoCD</a></strong> pipelines.</li>
<li>And finally to define the GoCD <strong>pipelines as code</strong> we use the <strong><a href="https://github.com/tomzo/gocd-yaml-config-plugin">YAML configuration plugin</a></strong></li>
</ul>

<h1 id="walkthrough-the-work">Walkthrough the work</h1>

<p>Now once we know all the components needed to setup the website deployment, we can plan the work and get busy.
At the high level we must do all of these tasks:</p>

<ol>
<li>Build a hugo website up to the point of generating a static site.</li>
<li>Setup deployment of static site to github pages. So that it is hosted at <code>kudulab.github.io</code>.</li>
<li>Buy the domain, setup DNS zone and records, so that <code>kudulab.io</code> resolves worldwide.</li>
<li>Configure github pages to generate SSL certificate for <code>kudulab.io</code> and enforce https.</li>
<li>Configure Disqus comment section.</li>
<li>Configure google analytics.</li>
</ol>

<h2 id="building-website-with-hugo">Building website with hugo</h2>

<p>One of the benefits of hugo is a rich documentation, we can just follow the <a href="https://gohugo.io/getting-started/quick-start/">quickstart</a> to get a minimal working website.</p>

<h3 id="setup-hugo">Setup hugo</h3>

<p>You can follow the <a href="https://gohugo.io/getting-started/quick-start/#step-1-install-hugo">official guide</a> and install hugo on your workstation and all the CI-agents.</p>

<p>However, we recommend a different approach - use docker and <a href="https://github.com/ai-traders/dojo">Dojo</a> to pull a suitable docker image just before hugo is needed. Although Dojo is a topic for another post, the two biggest benefits are</p>

<ul>
<li>you don&rsquo;t need to install hugo on your host and all CI-agents, but rather install docker and <a href="https://github.com/ai-traders/dojo">Dojo</a> just once for all the current and future projects you may be responsible for.</li>
<li>the website project we are building now will have a <strong>version-controlled reference</strong> to an exact hugo environment which is required. So even if we rerun a task a year from now, we are guaranteed, that the same tools will be used then, as now, when we got it working.</li>
</ul>

<p>With dojo setup becomes very simple because we have already published a functional <a href="https://github.com/kudulab/docker-hugo-dojo">hugo-dojo</a> docker image.
At the root of our website project run</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">mkdir src
<span style="color:#fff;font-weight:bold">cd</span> src</code></pre></div>
<p>Then create a <code>Dojofile</code>:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">DOJO_DOCKER_IMAGE=&#34;kudulab/hugo-dojo:1.0.0&#34;
DOJO_DOCKER_OPTIONS=&#34;-p 1313:1313&#34;</pre></div>
<p>And run <code>dojo</code>.
This will pull the image and enter into docker container with hugo installed and the <code>src</code> directory mounted into current directory <code>/dojo/work</code>. You should see output like this and then interactive shell prompt:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-console" data-lang="console">tomzo@073c1c477b1f:~/code/public-blog2/src$ dojo
2019/04/23 19:00:00 [ 1]  INFO: (main.main) Dojo version 0.3.1
2019/04/23 19:00:00 [20]  INFO: (main.DockerDriver.HandleRun) docker command will be:
 docker run --rm -v /home/tomzo/code/public-blog2/src:/dojo/work -v /home/tomzo:/dojo/identity:ro --env-file=/tmp/dojo-environment-dojo-src-2019-04-23_19-00-00-67126061 -v /tmp/.X11-unix:/tmp/.X11-unix -p 1313:1313 -ti --name=dojo-src-2019-04-23_19-00-00-67126061 kudulab/hugo-dojo:1.0.0
23-04-2019 19:00:01 Dojo entrypoint info: Sourcing: /etc/dojo.d/variables/50-variables.sh
23-04-2019 19:00:01 Dojo entrypoint info: Sourcing: /etc/dojo.d/scripts/50-fix-uid-gid.sh
+ usermod -u 1000 dojo
usermod: no changes
+ groupmod -g 1000 dojo
+ chown 1000:1000 -R /home/dojo
23-04-2019 19:00:01 Dojo entrypoint info: dojo init finished (interactive shell)
dojo@864baf626aa5(hugodojo):/dojo/work$</code></pre></div>
<h3 id="create-new-site">Create new site</h3>

<p>Either way, once we have <code>hugo</code> available, we can generate an empty site structure.
From <code>src</code> run:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">hugo new site --force .</code></pre></div>
<p>(force is needed to ignore the existing <code>Dojofile</code> file)</p>

<p>Then, we need to choose and add the <a href="https://themes.gohugo.io/">theme</a>. If you want to manage the theme as git submodule, run this from the root of the project (not from the docker container):</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git submodule add https://github.com/luizdepra/hugo-coder.git src/themes/hugo-coder</code></pre></div>
<p>Then, configure hugo to use a theme, in <code>config.toml</code> add the name of the theme:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-toml" data-lang="toml">theme = <span style="color:#0ff;font-weight:bold">&#39;hugo-coder&#39;</span></code></pre></div>
<p>We chose <a href="https://github.com/luizdepra/hugo-coder">hugo-coder</a> theme since it is blog-ish and nice enough. Although particularly for this theme we needed much longer configuration to start from, available on the <a href="https://github.com/luizdepra/hugo-coder/wiki/Configurations#complete-example">wiki</a>.</p>

<p>By now you should be able to see a live preview of the site, from the dojo docker container run:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">hugo server -D --bind 0.0.0.0 --baseURL http://localhost:1313</pre></div>
<p>Then open <a href="http://localhost:1313">http://localhost:1313</a> in your browser.</p>

<p>Since live preview is an operation we will often execute, we might as well script it.
Let&rsquo;s start <code>./tasks</code> bash file with the following content:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#0f0;font-weight:bold">#!/bin/bash
</span><span style="color:#0f0;font-weight:bold"></span><span style="color:#fff;font-weight:bold">set</span> -e

command=<span style="color:#0ff;font-weight:bold">&#34;</span>$1<span style="color:#0ff;font-weight:bold">&#34;</span>
<span style="color:#fff;font-weight:bold">case</span> <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>command<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span> in
  live_preview)
      <span style="color:#fff;font-weight:bold">cd</span> src
      dojo <span style="color:#0ff;font-weight:bold">&#34;hugo server -D --bind 0.0.0.0 --baseURL http://localhost:1313&#34;</span>
      ;;
  *)
      <span style="color:#fff;font-weight:bold">echo</span> <span style="color:#0ff;font-weight:bold">&#34;Invalid command: &#39;</span><span style="color:#0ff;font-weight:bold">${</span>command<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#39;&#34;</span>
      <span style="color:#fff;font-weight:bold">exit</span> <span style="color:#ff0;font-weight:bold">1</span>
      ;;
<span style="color:#fff;font-weight:bold">esac</span></code></pre></div>
<p>Now we at the root of our project, we can run <code>./tasks live_preview</code> and open <a href="http://localhost:1313">http://localhost:1313</a> in the browser to work on the page content.</p>

<h3 id="generating-static-site">Generating static site</h3>

<p>Live preview is nice for development, but our website has to be compiled into a static website before deployment.
So for a more accurate preview we should setup a similar hosting environment.
Let&rsquo;s generate the static page:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">hugo --baseUrl=http://localhost:8088</code></pre></div>
<p>This will produce <code>public</code> directory (in our project structure that is <code>src/public</code>). By now it is nice to add it to <code>.gitignore</code>.</p>

<p>We can create a minimal hosting environment using docker and <a href="https://docs.docker.com/samples/library/httpd/">Apache image</a>, from the root of the project run:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">docker run -d -p <span style="color:#ff0;font-weight:bold">8088</span>:80 --name www-host -v <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>PWD<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">/src/public&#34;</span>:/usr/local/apache2/htdocs/ httpd:2.4.29-alpine</code></pre></div>
<p>In the browser <a href="http://localhost:8088">http://localhost:8088</a> should return the same page which live preview did.</p>

<p>We can script generating the site and creating the demo host, in our <code>./tasks</code> file add:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#0f0;font-weight:bold">#!/bin/bash
</span><span style="color:#0f0;font-weight:bold"></span><span style="color:#fff;font-weight:bold">set</span> -e

command=<span style="color:#0ff;font-weight:bold">&#34;</span>$1<span style="color:#0ff;font-weight:bold">&#34;</span>
<span style="color:#fff;font-weight:bold">case</span> <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>command<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span> in
  <span style="color:#007f7f"># [...]</span>
  demo_host)
      docker run -d -p <span style="color:#ff0;font-weight:bold">8088</span>:80 --name www-host<span style="color:#0ff;font-weight:bold">\
</span><span style="color:#0ff;font-weight:bold"></span>        -v <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>PWD<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">/src/public&#34;</span>:/usr/local/apache2/htdocs/<span style="color:#0ff;font-weight:bold">\
</span><span style="color:#0ff;font-weight:bold"></span>        httpd:2.4.29-alpine
      ;;
  cleanup)
      docker stop www-host; docker rm www-host
      ;;
  generate)
      <span style="color:#fff;font-weight:bold">if</span> [[ -z <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>KUDU_ENVIRONMENT<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span> ]]; <span style="color:#fff;font-weight:bold">then</span>
        <span style="color:#fff;font-weight:bold">echo</span> <span style="color:#0ff;font-weight:bold">&#34;KUDU_ENVIRONMENT is not set&#34;</span>
        <span style="color:#fff;font-weight:bold">exit</span> <span style="color:#ff0;font-weight:bold">1</span>
      <span style="color:#fff;font-weight:bold">fi</span>
      <span style="color:#007f7f"># baseUrl in static page for production is different than for testing</span>
      <span style="color:#fff;font-weight:bold">if</span> [[ <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>KUDU_ENVIRONMENT<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span> == <span style="color:#0ff;font-weight:bold">&#34;testing&#34;</span> ]]; <span style="color:#fff;font-weight:bold">then</span>
        base_url=<span style="color:#0ff;font-weight:bold">&#34;//localhost:8088/&#34;</span>
      <span style="color:#fff;font-weight:bold">elif</span> [[ <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>KUDU_ENVIRONMENT<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span> == <span style="color:#0ff;font-weight:bold">&#34;production&#34;</span> ]]; <span style="color:#fff;font-weight:bold">then</span>
        base_url=<span style="color:#0ff;font-weight:bold">&#34;https://kudulab.github.io/&#34;</span>
      <span style="color:#fff;font-weight:bold">else</span>
        <span style="color:#fff;font-weight:bold">echo</span> <span style="color:#0ff;font-weight:bold">&#34;Unsupported KUDU_ENVIRONMENT=</span><span style="color:#0ff;font-weight:bold">${</span>KUDU_ENVIRONMENT<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">, exit 1&#34;</span>
        <span style="color:#fff;font-weight:bold">exit</span> <span style="color:#ff0;font-weight:bold">1</span>
      <span style="color:#fff;font-weight:bold">fi</span>
      <span style="color:#fff;font-weight:bold">cd</span> src
      rm -rf public/*
      dojo <span style="color:#0ff;font-weight:bold">&#34;hugo --baseUrl=</span><span style="color:#0ff;font-weight:bold">${</span>base_url<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>
      ;;
  *)
      <span style="color:#fff;font-weight:bold">echo</span> <span style="color:#0ff;font-weight:bold">&#34;Invalid command: &#39;</span><span style="color:#0ff;font-weight:bold">${</span>command<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#39;&#34;</span>
      <span style="color:#fff;font-weight:bold">exit</span> <span style="color:#ff0;font-weight:bold">1</span>
      ;;
<span style="color:#fff;font-weight:bold">esac</span></code></pre></div>
<p>To play nice, we should automate the process of testing if hosted website actually has the expected content.
In a larger website project we could implement stronger tests with selenium or alike framework.
For the purposes of this blog, we perform a simple smoke test, using curl and checking for the unique pieces of the page.
We use bats to implement the simple test:</p>

<p><code>test/integration/bats/test.bats</code></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">load <span style="color:#0ff;font-weight:bold">&#39;/opt/bats-support/load.bash&#39;</span>
load <span style="color:#0ff;font-weight:bold">&#39;/opt/bats-assert/load.bash&#39;</span>

@test <span style="color:#0ff;font-weight:bold">&#34;home page is available&#34;</span> {
  run /bin/bash -c <span style="color:#0ff;font-weight:bold">&#34;curl -i -L localhost:8088&#34;</span>
  assert_output --partial <span style="color:#0ff;font-weight:bold">&#34;200 OK&#34;</span>
  assert_output --partial <span style="color:#0ff;font-weight:bold">&#34;&lt;title&gt;KuduLab&lt;/title&gt;&#34;</span>
  assert_output --partial <span style="color:#0ff;font-weight:bold">&#34;Home&#34;</span>
  assert_output --partial <span style="color:#0ff;font-weight:bold">&#34;Projects&#34;</span>
  assert_output --partial <span style="color:#0ff;font-weight:bold">&#34;About&#34;</span>
  assert_equal <span style="color:#0ff;font-weight:bold">&#34;</span>$status<span style="color:#0ff;font-weight:bold">&#34;</span> <span style="color:#ff0;font-weight:bold">0</span>
}</code></pre></div>
<p>The test can be scripted in <code>./tasks</code>, add a test task:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">  <span style="color:#fff;font-weight:bold">test</span>)
      bats <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#fff;font-weight:bold">$(</span><span style="color:#fff;font-weight:bold">pwd</span><span style="color:#fff;font-weight:bold">)</span><span style="color:#0ff;font-weight:bold">/test/integration/bats&#34;</span>
      ;;</code></pre></div>
<p>Then we can start running generate and test on a GoCD pipeline to make sure it still works while we introduce changes.
At the root of our project create <code>pipeline.gocd.yaml</code></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">format_version: <span style="color:#ff0;font-weight:bold">4</span>
pipelines:
  public-blog:
    group: www
    label_template: <span style="color:#0ff;font-weight:bold">&#34;${git[:8]}&#34;</span>
    materials:
      git:
        type: configrepo
    stages:
      - test:
          clean_workspace: <span style="color:#fff;font-weight:bold">true</span>
          environment_variables:
            KUDU_ENVIRONMENT: testing
          jobs:
            test:
              <span style="color:#007f7f"># depending on your setup, either change the elastic_profile_id or use resources</span>
              elastic_profile_id: w.c1.m1024.e5
              tasks:
                - exec:
                    command: /bin/bash
                    arguments:
                      - -c
                      - ./tasks generate
                - exec:
                    command: /bin/bash
                    arguments:
                      - -c
                      - ./tasks demo_host
                - exec:
                    command: /bin/bash
                    arguments:
                      - -c
                      - ./tasks test
                - exec:
                    run_if: any
                    command: /bin/bash
                    arguments:
                      - -c
                      - ./tasks cleanup</code></pre></div>
<p>By now we should have committed all files and pushed to git server.
Then to finish the pipeline setup, we should add configuration repository to the GoCD server using the <a href="https://docs.gocd.org/current/advanced_usage/pipelines_as_code.html#storing-pipeline-configuration-in-json">documented steps</a>.</p>

<h2 id="deployment-to-github-pages">Deployment to github pages</h2>

<p>Github pages deployments are very simple - we just need to commit and push our static site to a repository with a <a href="https://gohugo.io/hosting-and-deployment/hosting-on-github/#github-user-or-organization-pages">magic name</a>.
We are building a personal blog, initially to be hosted at <code>kudulab.github.io</code>, therefore we must create a github repository named <code>kudulab.github.io</code>.
We already have a task to generate the production site, which produces static site in <code>src/public</code>.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">KUDU_ENVIRONMENT=production ./tasks generate</code></pre></div>
<p>So in order to deploy it, we only need to commit all the generated content into <strong>second</strong> repository <code>kudulab.github.io</code> and push it to github, which will trigger github hosting to update content on <code>https://kudulab.github.io</code>.
We can automate this operation in the <code>./tasks</code> script:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">publish)
    git_ref=<span style="color:#fff;font-weight:bold">$(</span>git log -1 --pretty=<span style="color:#0ff;font-weight:bold">&#39;format:%H&#39;</span><span style="color:#fff;font-weight:bold">)</span>
    git clone git@github.com:kudulab/kudulab.github.io.git kudulab.github.io
    <span style="color:#fff;font-weight:bold">cd</span> kudulab.github.io
    <span style="color:#fff;font-weight:bold">for</span> a_file in *; <span style="color:#fff;font-weight:bold">do</span>
      rm -rf <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>a_file<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>
    <span style="color:#fff;font-weight:bold">done</span>
    cp -r ../src/public/* .
    git add .
    git commit -m <span style="color:#0ff;font-weight:bold">&#34;generated from git ref: </span><span style="color:#0ff;font-weight:bold">${</span>git_ref<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span> || <span style="color:#fff;font-weight:bold">true</span>
    git push
    ;;</code></pre></div>
<p>Therefore the entire generate and publish procedure can be executed with</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">KUDU_ENVIRONMENT=production ./tasks generate
./tasks publish</code></pre></div>
<p>Above 2 steps can be added as a stage in the GoCD pipeline:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">- publish:
    clean_workspace: <span style="color:#fff;font-weight:bold">true</span>
    environment_variables:
      KUDU_ENVIRONMENT: production
    jobs:
      publish:
        elastic_profile_id: w.c1.m1024.e5
        tasks:
          - exec:
              command: /bin/bash
              arguments:
                - -c
                - ./tasks generate
          - exec:
              command: /bin/bash
              arguments:
                - -c
                - ./tasks publish</code></pre></div>
<h4 id="versioning-and-releases">Versioning and releases</h4>

<p>It is technically possible to deploy site on each commit. However we prefer to publish only such content, which was previously released with changes documented in the changelog. For that purpose, we have published <a href="https://github.com/kudulab/releaser">releaser</a> - a set of common bash functions to help with managing the changelog and git releases.
To start using the releaser, at the top of <code>./tasks</code> file add:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">RELEASER_VERSION=<span style="color:#0ff;font-weight:bold">&#34;2.1.0&#34;</span>
RELEASER_FILE=<span style="color:#0ff;font-weight:bold">&#34;ops/releaser-</span><span style="color:#0ff;font-weight:bold">${</span>RELEASER_VERSION<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>

mkdir -p ops
<span style="color:#fff;font-weight:bold">if</span> [[ ! -f $RELEASER_FILE ]];<span style="color:#fff;font-weight:bold">then</span>
  wget --quiet -O $RELEASER_FILE https://github.com/kudulab/releaser/releases/download/<span style="color:#0ff;font-weight:bold">${</span>RELEASER_VERSION<span style="color:#0ff;font-weight:bold">}</span>/releaser
<span style="color:#fff;font-weight:bold">fi</span>
<span style="color:#fff;font-weight:bold">source</span> $RELEASER_FILE</code></pre></div>
<p>There are 2 useful operations we can add in <code>./tasks</code></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">set_version)
    releaser::bump_changelog_version <span style="color:#0ff;font-weight:bold">&#34;</span>$2<span style="color:#0ff;font-weight:bold">&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;</span>$3<span style="color:#0ff;font-weight:bold">&#34;</span>
    ;;
release)
    releaser::verify_release_ready
    releaser::git_tag_from_changelog
    ;;</code></pre></div>
<p>We can use <code>./tasks set_version 0.1.0</code> to manage the version and release date the top of the changelog and <code>./tasks release</code> to add git tag to the repository with the version from top of the changelog.</p>

<p>To cut our first release, we should initialize a changelog.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">touch CHANGELOG.md
./tasks set_version 0.1.0</pre></div>
<p>This should produce output like:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">24-04-2019 09:43:01 RELEASER info: New version will be: 0.1.0
24-04-2019 09:43:01 RELEASER info: Bumped to 0.1.0 in CHANGELOG.md</pre></div>
<p>We should now document changes we have made in the project since last release, in case of our first release, the changelog could look like this:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-md" data-lang="md"><span style="font-weight:bold">### 0.1.0 (2019-Apr-15)
</span><span style="font-weight:bold"></span>
Initial release, empty site deployed to kudulab.github.io</code></pre></div>
<p>The last step, before deployment would be to add automated code releases to the GoCD pipeline. It is enough to add <code>./tasks release</code> in <code>release</code> stage.
The pipeline YAML should look like this by now:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">format_version: <span style="color:#ff0;font-weight:bold">4</span>
pipelines:
  public-blog:
    group: www
    label_template: <span style="color:#0ff;font-weight:bold">&#34;${git[:8]}&#34;</span>
    materials:
      git:
        type: configrepo
    stages:
      - test:
          clean_workspace: <span style="color:#fff;font-weight:bold">true</span>
          environment_variables:
            KUDU_ENVIRONMENT: testing
          jobs:
            test:
              elastic_profile_id: w.c1.m1024.e5
              tasks:
                - exec:
                    command: /bin/bash
                    arguments:
                      - -c
                      - ./tasks generate
                - exec:
                    command: /bin/bash
                    arguments:
                      - -c
                      - ./tasks demo_host
                - exec:
                    command: /bin/bash
                    arguments:
                      - -c
                      - ./tasks test
                - exec:
                    run_if: any
                    command: /bin/bash
                    arguments:
                      - -c
                      - ./tasks cleanup
      - release:
          clean_workspace: <span style="color:#fff;font-weight:bold">true</span>
          jobs:
            code:
              elastic_profile_id: w.c1.m1024.e5
              tasks:
                - exec:
                    command: /bin/bash
                    arguments:
                      - -c
                      - ./tasks release
      - publish:
          clean_workspace: <span style="color:#fff;font-weight:bold">true</span>
          environment_variables:
            KUDU_ENVIRONMENT: production
          jobs:
            publish:
              elastic_profile_id: w.c1.m1024.e5
              tasks:
                - exec:
                    command: /bin/bash
                    arguments:
                      - -c
                      - ./tasks generate
                - exec:
                    command: /bin/bash
                    arguments:
                      - -c
                      - ./tasks publish</code></pre></div>
<p>Now we can commit and push, then watch the pipeline running the release and deployment.
When we visit <code>kudulab.github.io</code> the page should be there.</p>

<h2 id="domain-and-dns-setup">Domain and DNS setup</h2>

<p>Often when choosing domain name registrar we also get access to a DNS server.
For our purposes, it is important that we can access DNS as a service over HTTP API and preferably there is a terraform provider for it.
Unoriginally, we went with AWS Route 53, which is well documented and supported by the <a href="https://www.terraform.io/docs/providers/aws/r/route53_record.html">terraform AWS provider</a>.</p>

<h3 id="install-terraform">Install terraform</h3>

<p>You can install terraform and AWS plugin yourself or leverage <a href="https://github.com/ai-traders/dojo">Dojo</a> and the <a href="https://github.com/kudulab/docker-terraform-dojo">terraform-dojo</a> docker image:</p>

<p>We will manage infrastructure (the DNS records) from <code>terraform</code> directory:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">mkdir -p terraform</code></pre></div>
<p>To declare which <a href="https://github.com/kudulab/docker-terraform-dojo">terraform-dojo</a> docker image to use, we create a <code>Dojofile</code></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">DOJO_DOCKER_IMAGE=&#34;kudulab/terraform-dojo:1.0.2&#34;</pre></div>
<p>Then run <code>dojo</code> to enter a container with terraform and several plugins installed.</p>

<h3 id="provision-dns">Provision DNS</h3>

<p>We start with buying the domain using AWS management console. The process is quite straightforward. You need an <a href="https://aws.amazon.com/account/">AWS account</a>, then login to the management console, go to <a href="https://console.aws.amazon.com/route53/home#DomainListing:">route53</a> and click on big blue button &ldquo;Register Domain&rdquo;.</p>

<p>Once you are done with purchasing the domain, there will be a DNS zone created already, which you can see in <a href="https://console.aws.amazon.com/route53/home#hosted-zones:">Hosted zones</a>. Notice the Hosted Zone ID, which is visible on the screenshot below:</p>

<p><img src="https://kudulab.io/images/aws_dns_zone.png" alt="aws zone screenshot" /></p>

<p><a href="https://help.github.com/en/articles/setting-up-an-apex-domain">Github pages</a> documentation is very helpful in guiding us through the process of DNS setup. Since we are building a website on an apex domain, we <a href="https://www.isc.org/blogs/cname-at-the-apex-of-a-zone/">cannot simply create a CNAME</a> record from <code>kudulab.io</code> to <code>kudulab.github.io</code>.
Instead we will provision DNS <code>A</code> records so that <code>kudulab.io</code> resolves into IPs of github pages load balancer. These are specified in the <a href="https://help.github.com/en/articles/setting-up-an-apex-domain#configuring-a-records-with-your-dns-provider">github pages documentation</a>.</p>

<p>We declare the desired infrastructure in <code>dns.tf</code> terraform file:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"># root zone was created externally,
# we don&#39;t manage the zone in infra of the blog
# because zone is shared by many services
variable &#34;root_zone_id&#34; {
  default = &#34;Z1B6OG086ITGV2&#34;
}

# Configure the AWS Provider
provider &#34;aws&#34; {
  # You can provide your credentials via
  # the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY, environment variables
  region     = &#34;us-east-1&#34;
}

# List of IPs on https://help.github.com/en/articles/setting-up-an-apex-domain#configuring-a-records-with-your-dns-provider
resource &#34;aws_route53_record&#34; &#34;www&#34; {
  zone_id = &#34;${var.root_zone_id}&#34;
  name    = &#34;kudulab.io&#34;
  type    = &#34;A&#34;
  ttl     = 3600
  records = [
    &#34;185.199.108.153&#34;,
    &#34;185.199.109.153&#34;,
    &#34;185.199.110.153&#34;,
    &#34;185.199.111.153&#34;
  ]
}</pre></div>
<p>A typical workflow with terraform is</p>

<ol>
<li><a href="https://www.terraform.io/docs/commands/init.html">terraform init</a> to perform initialization in current directory and optional <a href="https://www.terraform.io/docs/commands/init.html#backend-initialization">backend</a></li>
<li><a href="https://www.terraform.io/docs/commands/plan.html">terraform plan</a> which compares current infrastructure state to the desired one, which we defined in <code>*.tf</code> files. It can output a plan file with actions to take.</li>
<li><a href="https://www.terraform.io/docs/commands/apply.html">terraform apply</a> which if used with a plan file, will execute previously planned actions.</li>
</ol>

<p>So in the simplest form, to create our infrastructure we would run:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">terraform init
terraform plan -out=&#34;deployment.tfplan&#34;
terraform apply deployment.tfplan</pre></div>
<p>However, particularly in our infrastructure we use <a href="https://www.terraform.io/docs/backends/types/consul.html">consul as backend for terraform state</a> store and we use <a href="https://www.vaultproject.io/">HashiCorp Vault</a> to provide AWS authentication credentials. With GoCD usage of vault is not necessary, you could alternatively use a secure environment variables to <a href="https://api.gocd.org/current/#encrypt-a-plain-text-value">encrypt</a> the <code>AWS_SECRET_ACCESS_KEY</code> and then place the value in gocd yaml.
To encrypt the secret, you can use curl:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">curl &#39;https://ci.example.com/go/api/admin/encrypt&#39; \
  -u &#39;username:password&#39; \
  -H &#39;Accept: application/vnd.go.cd.v1+json&#39; \
  -H &#39;Content-Type: application/json&#39; \
  -X POST -d &#39;{
    &#34;value&#34;: &#34;&lt;your secret access key&gt;&#34;
  }&#39;</pre></div>
<p>The server will respond with</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">{
  &#34;_links&#34; : {
    &#34;doc&#34; : {
      &#34;href&#34; : &#34;https://api.gocd.org/#encryption&#34;
    },
    &#34;self&#34; : {
      &#34;href&#34; : &#34;https://ci.example.com/go/api/admin/encrypt&#34;
    }
  },
  &#34;encrypted_value&#34; : &#34;AES:GUkf7B+eai1yfcpOWfdtJQ==:2cOCnJtg2HD4eJOrVGXHEN6c/q8RYZyfebVLDCbP+JY=&#34;
}</pre></div>
<p>Then in GoCD yaml add the <code>encrypted_value</code> to <code>secure_variables</code> at stage or job level:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">secure_variables:
  AWS_SECRET_ACCESS_KEY: <span style="color:#0ff;font-weight:bold">&#34;AES:GUkf7B+eai1yfcpOWfdtJQ==:2cOCnJtg2HD4eJOrVGXHEN6c/q8RYZyfebVLDCbP+JY=&#34;</span></code></pre></div>
<p>Converging DNS can be scripted in <code>./tasks</code> file with the following snippet:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#fff;font-weight:bold">function</span> tf_ops {
  operation=$1

  <span style="color:#fff;font-weight:bold">cd</span> terraform/
  terraform init -backend-config path=terraform/kudu-www
  <span style="color:#fff;font-weight:bold">if</span> [[ <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>operation<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span> == <span style="color:#0ff;font-weight:bold">&#34;create&#34;</span> ]]; <span style="color:#fff;font-weight:bold">then</span>
    terraform plan -out=<span style="color:#0ff;font-weight:bold">&#34;kudu_deployment.tfplan&#34;</span>
  <span style="color:#fff;font-weight:bold">elif</span> [[ <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>operation<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span> == <span style="color:#0ff;font-weight:bold">&#34;destroy&#34;</span> ]]; <span style="color:#fff;font-weight:bold">then</span>
    terraform plan -out=<span style="color:#0ff;font-weight:bold">&#34;kudu_deployment.tfplan&#34;</span> -destroy
  <span style="color:#fff;font-weight:bold">fi</span>
  terraform apply kudu_deployment.tfplan
}

command=<span style="color:#0ff;font-weight:bold">&#34;</span>$1<span style="color:#0ff;font-weight:bold">&#34;</span>
<span style="color:#fff;font-weight:bold">case</span> <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>command<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span> in
  _set_dns)
      tf_ops <span style="color:#0ff;font-weight:bold">&#34;create&#34;</span>
      ;;
  set_dns)
      <span style="color:#007f7f"># AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY from vault</span>
      <span style="color:#fff;font-weight:bold">export</span> AWS_ACCESS_KEY_ID=<span style="color:#fff;font-weight:bold">$(</span>read_from_vault_or_die <span style="color:#0ff;font-weight:bold">&#34;aws&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;access_key_id&#34;</span><span style="color:#fff;font-weight:bold">)</span>
      <span style="color:#fff;font-weight:bold">export</span> AWS_SECRET_ACCESS_KEY=<span style="color:#fff;font-weight:bold">$(</span>read_from_vault_or_die <span style="color:#0ff;font-weight:bold">&#34;aws&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;secret_access_key&#34;</span><span style="color:#fff;font-weight:bold">)</span>
      dojo -c terraform/Dojofile <span style="color:#0ff;font-weight:bold">&#34;./tasks _set_dns&#34;</span>
      ;;
<span style="color:#007f7f"># [...]</span>
<span style="color:#fff;font-weight:bold">esac</span></code></pre></div>
<p>The user identified with <code>AWS_ACCESS_KEY_ID</code> must have sufficient permissions to change DNS resources in AWS. For example you can use the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html">AWS managed policy</a> <code>AmazonRoute53FullAccess</code>.</p>

<p>With such setup, we can idempotently provision DNS records with <code>./tasks set_dns</code>.
The last point would be to setup this step on a GoCD pipeline. We can add one more stage in <code>pipeline.gocd.yaml</code>:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">- dns:
    clean_workspace: <span style="color:#fff;font-weight:bold">true</span>
    environment_variables:
      KUDU_ENVIRONMENT: production
    secure_variables:
      VAULT_TOKEN: <span style="color:#0ff;font-weight:bold">&#34;AES:bYwjpIz02AtPshnMBaBdnA==:BwACwa5fWInrHU2xXfyJlM2qFKk2lE9g+d5gGAFTl3sjg/sLdJqDfKW3Qki4vwfH&#34;</span>
    jobs:
      provision:
        elastic_profile_id: w.c1.m1024.e5
        tasks:
          - exec:
              command: /bin/bash
              arguments:
                - -c
                - ./tasks set_dns</code></pre></div>
<p>After <code>dns</code> stage completes, we may need to wait a moment before DNS records propagate around the world, a nice tool to watch the progress is available at <a href="https://dnschecker.org">https://dnschecker.org</a></p>

<h4 id="configure-custom-domain-on-github-pages">Configure custom domain on github pages</h4>

<p>Several changes are required in our <code>tasks</code> script to make github pages serve page from <code>https://kudulab.io</code> rather than <code>https://kudulab.github.io</code>.</p>

<ol>
<li>We need to <a href="https://github.com/kudulab/public-blog/commit/65083c92e099f607aaa89f8269f2d380851e488e">update <code>baseUrl</code></a> when generating the production static site.</li>
<li>We need to <a href="https://github.com/kudulab/public-blog/commit/ac3be0b94df0074abf492fb439b0efe792cccb9b">commit <code>CNAME</code></a> at the root of github pages repository with our domain name - <code>kudulab.io</code>. This will configure github load balancer to serve a page for <code>kudulab.io</code> and it will trigger re-generation of the SSL certificate for <code>kudulab.io</code>.</li>
<li>To ensure that <code>https</code> is always used, we need to <a href="https://help.github.com/en/articles/securing-your-github-pages-site-with-https">edit settings on github</a> and check &ldquo;Enforce HTTPS&rdquo;.</li>
</ol>

<p>The <code>generate</code> and <code>publish</code> tasks should look like this now:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">generate)
    <span style="color:#fff;font-weight:bold">if</span> [[ -z <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>KUDU_ENVIRONMENT<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span> ]]; <span style="color:#fff;font-weight:bold">then</span>
      <span style="color:#fff;font-weight:bold">echo</span> <span style="color:#0ff;font-weight:bold">&#34;KUDU_ENVIRONMENT is not set&#34;</span>
      <span style="color:#fff;font-weight:bold">exit</span> <span style="color:#ff0;font-weight:bold">1</span>
    <span style="color:#fff;font-weight:bold">fi</span>
    <span style="color:#007f7f"># baseUrl in static page for production is different than for testing</span>
    <span style="color:#fff;font-weight:bold">if</span> [[ <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>KUDU_ENVIRONMENT<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span> == <span style="color:#0ff;font-weight:bold">&#34;testing&#34;</span> ]]; <span style="color:#fff;font-weight:bold">then</span>
      base_url=<span style="color:#0ff;font-weight:bold">&#34;//localhost:8088/&#34;</span>
    <span style="color:#fff;font-weight:bold">elif</span> [[ <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>KUDU_ENVIRONMENT<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span> == <span style="color:#0ff;font-weight:bold">&#34;production&#34;</span> ]]; <span style="color:#fff;font-weight:bold">then</span>
      base_url=<span style="color:#0ff;font-weight:bold">&#34;https://kudulab.io/&#34;</span>
    <span style="color:#fff;font-weight:bold">else</span>
      <span style="color:#fff;font-weight:bold">echo</span> <span style="color:#0ff;font-weight:bold">&#34;Unsupported KUDU_ENVIRONMENT=</span><span style="color:#0ff;font-weight:bold">${</span>KUDU_ENVIRONMENT<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">, exit 1&#34;</span>
      <span style="color:#fff;font-weight:bold">exit</span> <span style="color:#ff0;font-weight:bold">1</span>
    <span style="color:#fff;font-weight:bold">fi</span>
    <span style="color:#fff;font-weight:bold">cd</span> src
    rm -rf public/*
    dojo <span style="color:#0ff;font-weight:bold">&#34;hugo --baseUrl=</span><span style="color:#0ff;font-weight:bold">${</span>base_url<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>
    ;;
publish)
    git_ref=<span style="color:#fff;font-weight:bold">$(</span>git log -1 --pretty=<span style="color:#0ff;font-weight:bold">&#39;format:%H&#39;</span><span style="color:#fff;font-weight:bold">)</span>
    git clone git@github.com:kudulab/kudulab.github.io.git kudulab.github.io
    <span style="color:#fff;font-weight:bold">cd</span> kudulab.github.io
    <span style="color:#007f7f"># remove everything but for .git directory</span>
    <span style="color:#fff;font-weight:bold">for</span> a_file in *; <span style="color:#fff;font-weight:bold">do</span>
      rm -rf <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">${</span>a_file<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>
    <span style="color:#fff;font-weight:bold">done</span>
    cp -r ../src/public/* .
    <span style="color:#fff;font-weight:bold">echo</span> <span style="color:#0ff;font-weight:bold">&#34;kudulab.io&#34;</span> &gt; CNAME
    git add .
    git commit -m <span style="color:#0ff;font-weight:bold">&#34;generated from git ref: </span><span style="color:#0ff;font-weight:bold">${</span>git_ref<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span> || <span style="color:#fff;font-weight:bold">true</span>
    git push
    ;;</code></pre></div>
<h2 id="configure-disqus">Configure Disqus</h2>

<p>It is a very simple process - setup an account on <a href="https://disqus.com/">https://disqus.com/</a>
and configure a new site in the disqus admin panel. This will provide you with a site ID.</p>

<p>Then in hugo, we just need to add the ID in <code>src/config.toml</code></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">disqusShortname = &#34;your-id&#34;</pre></div>
<h2 id="configure-google-analytics">Configure google analytics</h2>

<p>Also a simple process, you register a site on google, which provides you with an ID.</p>

<p>Then in hugo, we just need to add the ID in <code>src/config.toml</code></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">googleAnalytics = &#34;your-id&#34;</pre></div>
<h2 id="summary">Summary</h2>

<p>Starting from nothing, we have built a website with code, infrastructure and operations checked-in the source control.
Now any changes can be introduced to production by git commits and running <code>git push</code> and watching GoCD pipeline deploying the site:</p>

<p><img src="https://kudulab.io/images/blog_gocd_pipe.png" alt="GoCD pipeline" /></p>

<p>While it may seem like an overkill to apply all of these efforts for a simple website, we find that this set of practices is very resilient to external changes because we have locked version of practically every dependency of this project. In this repository we have nearly every piece which makes the website work and controls its lifecycle, this makes maintenance straightforward and project easier to share.</p>

<p>Feel free to comment and ask questions, we&rsquo;ll certainly engage with you.</p>

<h4 id="references">References</h4>

<p>I have found following sites useful when working on this setup:</p>

<ul>
<li><a href="https://zwbetz.com/make-a-hugo-blog-from-scratch/">https://zwbetz.com/make-a-hugo-blog-from-scratch/</a> - nice overview of elements of hugo theme. Useful if you want to hack with the theme or create your own.</li>
<li><a href="https://aws.amazon.com/route53/faqs/">https://aws.amazon.com/route53/faqs/</a> - Amazon AWS Route 53 FAQ</li>
<li><a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html">IAM Best Practices</a></li>
<li><a href="https://gohugo.io/hosting-and-deployment/hosting-on-github/">Hugo documentation on hosting with github pages</a></li>
</ul>

      </div>

      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ait-lab" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </footer>
    </article>

    <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML-full">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$']],
        displayMath: [['$$','$$']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        TeX: { extensions: ["AMSmath.js", "AMSsymbols.js"] }
      }
    });
    MathJax.Hub.Queue(function() {
      
      
      
      var all = MathJax.Hub.getAllJax(), i;
      for(i = 0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
     © 2019
    
    
  </section>
</footer>

    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-138356014-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
